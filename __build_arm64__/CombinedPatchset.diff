unchanged:
--- a/libsolidity/analysis/GlobalContext.cpp
+++ b/libsolidity/analysis/GlobalContext.cpp
@@ -91,7 +91,7 @@ vector<Declaration const*> GlobalContext::declarations() const
 {
 	vector<Declaration const*> declarations;
 	declarations.reserve(m_magicVariables.size());
-	for (ASTPointer<Declaration const> const& variable: m_magicVariables)
+	for (ASTPointer<Declaration const> const variable: m_magicVariables)
 		declarations.push_back(variable.get());
 	return declarations;
 }
unchanged:
--- a/libsolidity/codegen/ContractCompiler.cpp
+++ b/libsolidity/codegen/ContractCompiler.cpp
@@ -512,13 +512,13 @@ bool ContractCompiler::visit(FunctionDefinition const& _function)
 	if (!_function.isConstructor())
 		// adding 1 for return address.
 		m_context.adjustStackOffset(parametersSize + 1);
-	for (ASTPointer<VariableDeclaration const> const& variable: _function.parameters())
+	for (ASTPointer<VariableDeclaration const> const variable: _function.parameters())
 	{
 		m_context.addVariable(*variable, parametersSize);
 		parametersSize -= variable->annotation().type->sizeOnStack();
 	}
 
-	for (ASTPointer<VariableDeclaration const> const& variable: _function.returnParameters())
+	for (ASTPointer<VariableDeclaration const> const variable: _function.returnParameters())
 		appendStackVariableInitialisation(*variable);
 
 	if (_function.isConstructor())
@@ -571,7 +571,7 @@ bool ContractCompiler::visit(FunctionDefinition const& _function)
 		if (stackLayout[i] != i)
 			solAssert(false, "Invalid stack layout on cleanup.");
 
-	for (ASTPointer<VariableDeclaration const> const& variable: _function.parameters() + _function.returnParameters())
+	for (ASTPointer<VariableDeclaration const> const variable: _function.parameters() + _function.returnParameters())
 		m_context.removeVariable(*variable);
 
 	m_context.adjustStackOffset(-(int)c_returnValuesSize);
unchanged:
--- a/libyul/optimiser/NameCollector.cpp
+++ b/libyul/optimiser/NameCollector.cpp
@@ -35,9 +35,9 @@ void NameCollector::operator()(VariableDeclaration const& _varDecl)
 void NameCollector::operator ()(FunctionDefinition const& _funDef)
 {
 	m_names.emplace(_funDef.name);
-	for (auto const arg: _funDef.parameters)
+	for (auto const& arg: _funDef.parameters)
 		m_names.emplace(arg.name);
-	for (auto const ret: _funDef.returnVariables)
+	for (auto const& ret: _funDef.returnVariables)
 		m_names.emplace(ret.name);
 	ASTWalker::operator ()(_funDef);
 }
unchanged:
--- a/test/libsolidity/SolidityTypes.cpp
+++ b/test/libsolidity/SolidityTypes.cpp
@@ -266,7 +266,7 @@ BOOST_AUTO_TEST_CASE(helper_bool_result)
 
 	BoolResult r7{true};
 	// Attention: this will implicitly convert to bool.
-	BoolResult r8{"true"};
+	BoolResult r8{true};
 	r7.merge(r8, logical_and<bool>());
 	BOOST_REQUIRE_EQUAL(r7.get(), true);
 	BOOST_REQUIRE_EQUAL(r7.message(), "");
unchanged:
--- a/test/tools/yulInterpreter/EVMInstructionInterpreter.cpp
+++ b/test/tools/yulInterpreter/EVMInstructionInterpreter.cpp
@@ -337,6 +337,8 @@ u256 EVMInstructionInterpreter::eval(
 		throw ExplicitlyTerminated();
 	case Instruction::POP:
 		break;
+    case Instruction::BLOBHASH:
+        return 0;
 	// --------------- invalid in strict assembly ---------------
 	case Instruction::JUMP:
 	case Instruction::JUMPI:
only in patch2:
unchanged:
--- a/libevmasm/BlockDeduplicator.h
+++ b/libevmasm/BlockDeduplicator.h
@@ -65,7 +65,7 @@ class BlockDeduplicator
 	/// Iterator that skips tags and skips to the end if (all branches of) the control
 	/// flow does not continue to the next instruction.
 	/// If the arguments are supplied to the constructor, replaces items on the fly.
-	struct BlockIterator: std::iterator<std::forward_iterator_tag, AssemblyItem const>
+	struct BlockIterator //: std::iterator<std::forward_iterator_tag, AssemblyItem const>
 	{
 	public:
 		BlockIterator(
@@ -83,6 +83,12 @@ class BlockDeduplicator
 		AssemblyItems::const_iterator end;
 		AssemblyItem const* replaceItem;
 		AssemblyItem const* replaceWith;
+
+		typedef std::forward_iterator_tag iterator_category;
+		typedef std::ptrdiff_t difference_type;
+		typedef AssemblyItems& reference;
+		typedef AssemblyItems* pointer;
+		typedef AssemblyItem value_type;
 	};
 
 	std::map<u256, u256> m_replacedTags;
only in patch2:
unchanged:
--- a/liblll/Parser.cpp
+++ b/liblll/Parser.cpp
@@ -67,8 +67,12 @@ void dev::lll::debugOutAST(ostream& _out, sp::utree const& _this)
 
 		break;
 	case sp::utree_type::int_type: _out << _this.get<int>(); break;
-	case sp::utree_type::string_type: _out << "\"" << _this.get<sp::basic_string<boost::iterator_range<char const*>, sp::utree_type::string_type>>() << "\""; break;
-	case sp::utree_type::symbol_type: _out << _this.get<sp::basic_string<boost::iterator_range<char const*>, sp::utree_type::symbol_type>>(); break;
+	case sp::utree_type::string_type:
+		_out << "\"";
+		operator<<(_out, _this.get<sp::basic_string<boost::iterator_range<char const*>, sp::utree_type::string_type>>()) << "\""; break;
+	case sp::utree_type::symbol_type:
+		operator<<(_out, _this.get<sp::basic_string<boost::iterator_range<char const*>, sp::utree_type::symbol_type>>());
+		break;
 	case sp::utree_type::any_type: _out << *_this.get<bigint*>(); break;
 	default: _out << "nil";
 	}
